Last Up : 08/19/2025
Ramp up Plan
------------
Learning Platforms for Python
-----------------------------
1. Python Tutorial  Source : https://www.python.org
2. https://pythoninstitute.org/
3. https://git-scm.com/downloads/win

Best
https://edube.org/learn/pe-1/programming-absolute-basics-compilation-vs-interpretation-11

AI LIST
........
Claude
Gemini
ChatGPT
perplexity
Grok
GPT5


3.1 PCEP™ – Certified Entry-Level Python Programmer
https://pythoninstitute.org/pcep

3.2 PCAP™ – Certified Associate Python Programmer
https://pythoninstitute.org/pcap


3.3 Crash course on Python by Google
https://www.coursera.org/learn/python-crash-course

3.4. Hugging face
	 Firebase
	 Claude
	 *** Model, Training, AI ****
	 *** Alogirthms extract from Claude ***

2. HTML
3. CSS
4. Javascript
5. React JS
6. Node JS

ML/AI Reading Plan for PMs
--------------------------
Intro
7. AI for Everyone https://www.coursera.org/learn/ai-for-everyone
8. Generative AI for Everyone https://www.coursera.org/learn/generative-ai-for-everyone
9. MIT Sloan  https://mitsloan.mit.edu/ideas-made-to-matter/machine-learning-explained

Diving Deep
10. Google ML https://developers.google.com/machine-learning/foundational-courses

Use cases
11. AWS – Gen AI Use Cases 
https://aws.amazon.com/ai/generative-ai/use-cases/?ams%23interactive-card-vertical%23pattern-data-2054833178.filter=%257B%2522filters%2522%253A%255B%255D%257D&ams%23interactive-card-vertical%23pattern-data-2054833177.filter=%257B%2522filters%2522%253A%255B%255D%257D
12. GCP – Gen AI Use Cases
https://cloud.google.com/use-cases/generative-ai?hl=en
13. Azure – AI Use Cases
https://www.microsoft.com/en-us/ai/ai-customer-stories

Get Technical
14.Kaggle - Learn (Python)
https://www.kaggle.com/learn

15.Kaggle – Competitions (glance through to understand different domains ML / AI is used)
https://www.kaggle.com/competitions

AI Project Management
16. The Art of AI Product Development book (paid)
https://www.manning.com/books/the-art-of-ai-product-development

17. AI Product Manager Course (paid)
https://www.productmanagementexercises.com/ai-product-manager


Python Tutorial - Coverage  - 08/05/2025
-----------------------------------------
Source : https://www.python.org

Tutorial | Python's syntax and features  *
Language reference | Syntax and language elements |


To refer later
--------------
The Python Standard Library. 
The Python Tutorial.
Extending and Embedding the Python Interpreter 
Python/C API Reference Manual  
https://betterstack.com/community/guides/scaling-python/python-errors/

A List of - Confluence

https://www.geeksforgeeks.org/angular-js/angularjs/ | Learning platform
https://huggingface.co/ | AI Community
https://docs.djangoproject.com/en/5.2/intro/tutorial01/
Operations supported by Timedelta Class
Integer literals
Floating-point literals
git py
https://www.greatfrontend.com/

Hugging face
Firebase
Claude
*** Model, Training, AI ****
*** Alogirthms extract from Claude ***

Debugging at Command line
>>> f"{today=:%B %d, %Y}" # using date format specifier and debugging
>>>'today=January 27, 2017''

>>> f"Today is {today:%B %d, %Y}"
'Today is August 07, 2025'


Where do you use Python?
Do you remember Battlefield 2, Battlefield 2142 and Battlefield Heroes - strategy and first person shooter games from EA DICE? All the games use Python for logic and server controls. Python is frequently used for creating open-source, free games, e.g., OpenRTS, PySol, Metin 2, or Frets On Fire - famous Guitar Hero-like games written in pygame.

And what about the major websites and services? Dropbox? UBER? Spotify? Pintrest? BuzzFeed? Yes. They were all written, to a greater or lesser extent, in Python. Other examples?

Internet Applications (BitTorrent, Jogger Publishing Assistant, TheCircle, TwistedMatrix)
3D CAD/CAM (FreeCAD, Fandango, Blender, Vintech RCAM)
Enterprise Applications (Odoo, Tryton, Picalo, LinOTP 2, RESTx)
Image Applications (Gnofract 4D, Gogh, imgSeek, MayaVi, VPython)
Mobile Applications (Aarlogic C05/3, AppBackup, Pyroute)
Office Applications (calibre, faces, Notalon, pyspread)
Personal Information Managers (BitPim, Narval, Prioritise, Task Coach, WikidPad)
(Source: https://wiki.python.org/moin/PythonProjects)


Generally, Python is a great choice for:

Web and Internet development (e.g., Django and Pyramid frameworks, Flask and Bottle micro-frameworks)
Scientific and numeric computing (e.g., SciPy - a collection of packages for the purposes of mathematics, science, and engineering; Ipython - an interactive shell that features editing and recording of work sessions)
Education (it's a brilliant language for teaching programming! And that's why we're offering this course to you!)
Desktop GUIs (e.g., wxWidgets, Kivy, Qt)
Software Development (build control, management, and testing - Scons, Buildbot, Apache Gump, Roundup, Trac)
Business applications (ERP and e-commerce systems - Odoo, Tryton)
(Source: https://www.python.org/about/apps)
And many, many other projects and development tools.


Python is a great choice for:

Web and Internet development (e.g., Django and Pyramid frameworks, Flask and Bottle micro-frameworks)
Scientific and numeric computing (e.g., SciPy - a collection of packages for the purposes of mathematics, science, and engineering; Ipython - an interactive shell that features editing and recording of work sessions)
Education (it's a brilliant language for teaching programming! And that's why we're offering this course to you!)
Desktop GUIs (e.g., wxWidgets, Kivy, Qt)
Software Development (build control, management, and testing - Scons, Buildbot, Apache Gump, Roundup, Trac)
Business applications (ERP and e-commerce systems - Odoo, Tryton)
(Source: https://www.python.org/about/apps)

Python eBook
Python Essentials 1: Aligned with PCEP-30-0X


Code Explainer
---------------
https://zzzcode.ai/python/code-explain

Code Checker
------------
https://techbeamers.com/python-code-checker/

Python Test
-----------
https://www.learnx.org/dashboard/python/2/10

Several websites and browser extensions can help you identify the technologies used to build a website
Websites	
BuiltWith	https://builtwith.com/
Ful.io	https://ful.io/
	
Browser extensions	
BuiltWith:	https://builtwith.com/toolbar
Wappalyzer:	https://www.wappalyzer.com
WhatRuns:	https://www.whatruns.com
Snov.io	https://snov.io/
Webspotter:	https://webspotters.in


Package Layout
--------------
package/
    __init__.py
    subpackage1/
        __init__.py
        moduleX.py
        moduleY.py
    subpackage2/
        __init__.py
        moduleZ.py
    moduleA.py
	
from .moduleY import spam
from .moduleY import spam as ham
from . import moduleY
from ..subpackage1 import moduleY
from ..subpackage2.moduleZ import eggs
from ..moduleA import foo



Python, pointers to note

Python Variables
----------------
In Python, variables are created the moment a value is assigned to them. Unlike some other programming languages, 
Python does not require explicit variable declaration or type specification before assignment.

To create a variable, use the assignment operator (=) to assign a value to a name. The variable's type is automatically 
inferred based on the assigned value. 

# Assigning an integer value
my_integer = 10

# Assigning a string value
my_string = "Hello, Python!"

# Assigning a floating-point value
my_float = 3.14



Data Type : Numbers
-------------------
17 / 3  # classic division returns a float
17 // 3  # floor division discards the fractional part
17 % 3  # the % operator returns the remainder of the division

Last printed expression in the variable "_"

tax = 12.5 / 100
price = 100.50
price * tax
12.5625
price + _
113.0625
round(_, 2)
113.06

'doesn\'t'  # use \' to escape the single quote...

Multiple lines
--------------
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")


Text
----

word = 'Python'
word[0]  # character in position 0  >> "P"
word[5]  # character in position 5 >> "n"

word[0:2]  # characters from position 0 (included) to 2 (excluded)    >> "Py"
word[2:5]  # characters from position 2 (included) to 5 (excluded)    >> "thon"

word[:2] + word[2:] 'Python'
word[:4] + word[4:] 'Python'

Lists
-------
cubes = [1, 8, 27, 65, 125]  # something's wrong here
4 ** 3  # the cube of 4 is 64, not 65!

cubes[3] = 64  # replace the wrong value

cubes.append(216)  # add the cube of 6
cubes.append(7 ** 3)  # and the cube of 7
>>> cubes
cubes
[1, 8, 27, 64, 125, 216, 343]

rgb = ["Red", "Green", "Blue"]
rgba = rgb
id(rgb) == id(rgba)  # they reference the same object

rgba.append("Alph")

While
-----
# Fibonacci series:
# the sum of two elements defines the next
a, b = 0, 1
while a < 10:
    print(a)
    a, b = b, a+b
	
	
Collection
----------
# Create a sample collection
users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}

# Strategy:  Iterate over a copy
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Strategy:  Create a new collection
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status

users['New']='New User'
>>> users
{'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active', 'New': 'New User'}		
		
list(range(5, 10))
[5, 6, 7, 8, 9]

list(range(0, 10, 3))
[0, 3, 6, 9]

list(range(-10, -100, -30))
[-10, -40, -70]

a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])
0 Mary
1 had
2 a
3 little
4 lamb


for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
		
		
while True:
    pass  # Busy-wait for keyboard interrupt (Ctrl+C)
	

def ask_ok(prompt, retries=4, reminder='Please try again!'):
    while True:
        reply = input(prompt)
        if reply in {'y', 'ye', 'yes'}:
            return True
        if reply in {'n', 'no', 'nop', 'nope'}:
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('invalid user response')
        print(reminder)
		
		
		
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")
	
	
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword

def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
		
		
		
		
cheeseshop("Limburger", "It's very runny, sir.",
   "It's really very, VERY runny, sir.",
   shopkeeper="Michael Palin",
   client="John Cleese",
   sketch="Cheese Shop Sketch")
	   
combined_example(1, 2, 3)
combined_example(1, 2, kwd_only=3)
combined_example(1, standard=2, kwd_only=3)
combined_example(pos_only=1, standard=2, kwd_only=3)

# Creating a tuple
my_tuple = ("apple", 123, True)

# Accessing elements
print(my_tuple[0])  # Output: apple

# Attempting to modify (will raise an error)
# my_tuple[0] = "orange"

fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
fruits.count('apple')

fruits.count('tangerine')

fruits.index('banana')

fruits.index('banana', 4)  # Find next banana starting at position 4

fruits.reverse()
fruits

fruits.append('grape')
fruits

fruits.sort()
fruits

fruits.pop()


for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
	
	
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for f in sorted(set(basket)):
    print(f)
	

string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
non_null = string1 or string2 or string3
non_null

fibo.py
-------
# Fibonacci numbers module

def fib(n):
    """Write Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n):
    """Return Fibonacci series up to n."""
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result


>>> Add the below at the end of the module, to pass the CLA to the .py file 
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
	
to the end of module

fibo.__name__

import fibo >>  fibo.fib(1000)
from fibo import fib, fib2 >> fib(1000)
from fibo import * >> fib(1000)

from fibo import fib as fibonacci

fibonacci(500)


Reverse String
--------------
def reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule
    return msg[::-1]    #     in the case of a 'from sound.effects import *'

'12'.zfill(5)
'-3.14'.zfill(7)
'3.14159265359'.zfill(5)

Exception
-----------
while True:
    try:
        x = int(input("Please enter a number: "))
        break
    except ValueError:
        print("Oops!  That was no valid number.  Try again...")
		
		
List Comprehension - with dual for statements
----------------------------------------------
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

and it’s equivalent to:

combs = []
for x in [1,2,3]:
    for y in [3,1,4]:
        if x != y:
            combs.append((x, y))


basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}

'orange' in basket                 # >> True
'crabgrass' in basket


# Demonstrate set operations on unique letters from two words

a = set('abracadabra')
b = set('alacazam')

>>> a 
>>> {'a', 'r', 'b', 'c', 'd'}

Looping Techniques
------------------
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.items():
    print(k, v)
	
Enumurate
----------
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
	
Fancier Output Formatting
-------------------------
year = 2016
event = 'Referendum'
f'Results of the {year} {event}'

Formatting
----------]

yes_votes = 42_572_654
total_votes = 85_705_149
percentage = yes_votes / total_votes
'{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)

print format : fancy print
--------------------------
A formatted string literal or f-string is a string literal that is prefixed with 'f' or 'F'. 
These strings may contain replacement fields, which are expressions delimited by curly braces {}

name = "Alice"
age = 30
salary = 50000

# Without the '=' sign
print(f"Name: {name}, Age: {age}")

# With the '=' sign for self-documenting expressions
print(f"{name=}, {age=}, {salary=}")

# Using it with an expression
print(f"Next year's age: {age + 1=}")



table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
for name, phone in table.items():
    print(f'{name:10} ==> {phone:10d}')

If a conversion is specified, the result of evaluating the expression is converted before 
formatting. Conversion '!s' calls str() on the result, '!r' calls repr(), and '!a' calls ascii().

name = "Fred"
f"He said his name is {name!r}."
f"He said his name is {repr(name)}."  # repr() is equivalent to !r

>>> "He said his name is 'Fred'."

width = 10
precision = 4
value = decimal.Decimal("12.34567")
f"result: {value:{width}.{precision}}"  # nested fields

>>>  'result:      12.35'

today = datetime(year=2017, month=1, day=27)
f"{today:%B %d, %Y}"  # using date format specifier
>>> January 27, 2017'

f"{today=:%B %d, %Y}" # using date format specifier and debugging


number = 1024
f"{number:#0x}"  # using integer format specifier

foo = "bar"
f"{ foo = }" # preserves whitespace

line = "The mill's closed"
f"{line = }"

f"{line = :20}"

f"{line = !r:20}"

Encapsulation is one of the core concepts in object-oriented programming and 
describes the bundling of data and methods operating on this data into one unit

https://nextjs.org/docs/getting-started/installation
https://stackblitz.com/edit/nextjs-eirnbv?file=app%2Fpage.tsx

class MyClass:
    """A simple example class"""
    i = 12345

    def __init__(self):
		self.data = 1
	
    def f(self):
        print (self.data)
		
		
>>> x = MyClass()
>>> x.data
1
>>> x.f()
1


class Dog:
    def __init__(self, name, breed):
        self.name = name  # 'self.name' refers to the instance's 'name' attribute
        self.breed = breed

    def bark(self):
        print(f"{self.name} says Woof!") # 'self.name' accesses the instance's name

my_dog = Dog("Buddy", "Golden Retriever")
my_dog.bark() # Output: Buddy says Woof!

self is a conventional name for the first parameter of a method within a class definition

class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # shared by all dogs
'canine'
>>> e.kind                  # shared by all dogs
'canine'
>>> d.name                  # unique to d
'Fido'
>>> e.name                  # unique to e
'Buddy'

class Dog:

    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # unexpectedly shared by all dogs
['roll over', 'play dead']

class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']


Yes, it is possible to define a Python method within a class that does 
not take any explicit arguments beyond the conventional self parameter 
(for instance methods) or no arguments at all (for static methods).

Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class):

Copy
x = MyClass()

1. Instance Methods without additional arguments:
Instance methods implicitly receive self as their first argument, which 
refers to the instance of the class on which the method is called. Even 
if the method's logic does not require any other input, self is still present.

class MyClass:
    def greet(self):
        """An instance method that takes no explicit arguments other than self."""
        print("Hello from MyClass!")

# Create an instance and call the method
obj = MyClass()
obj.greet()


Ver. 1
-------

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def where_is(point):
    match point:
        case Point(x=0, y=0):
            print("Origin")
        case Point(x=0, y=y):
            print(f"Y={y}")
        case Point(x=x, y=0):
            print(f"X={x}")
        case Point():
            print("Somewhere else")
        case _:
            print("Not a point")

>>> Locate_axis(Point(1,0))
X=1
>>> Locate_axis(Point(1,1))
No Where
>>> Locate_axis(Point(0,1))
Y=1
>>> Locate_axis(Point(0,0))
Origin
>>> Locate_axis(1)
Not a Point

>>> where_is(Point(1))
Traceback (most recent call last):
  File "<python-input-287>", line 1, in <module>
    where_is(Point(1))
             ~~~~~^^^
TypeError: Point.__init__() missing 1 required positional argument: 'y'


Ver 2
-----
class Point:
    __match_args__ = ('x', 'y')
    def __init__(self, x, y):
        self.x = x
        self.y = y

def where_is(points):
	match points:
		case []:
			print("No points")
		case [Point(0, 0)]:
			print("The origin")
		case [Point(x, y)]:
			print(f"Single point {x}, {y}")
		case [Point(0, y1), Point(0, y2)]:
			print(f"Two on the Y axis at {y1}, {y2}")
		case _:
			print("Something else")







-------------------
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Something's wrong with the internet"
			

Call the method by Class.Function and  Instance.method		

 
>>> class fibclass:
...     def fib(self,n):
...
...         """Write Fibonacci series up to n."""
...         a, b = 0, 1
...         while a < n:
...             print(a, end=' ')
...             a, b = b, a+b
...         print()
...
...         print('self')
...         self=1
...         print(self)
...
>>>
>>>
>>> fibclass.fib(100)
Traceback (most recent call last):
  File "<python-input-38>", line 1, in <module>
    fibclass.fib(100)
    ~~~~~~~~~~~~^^^^^
TypeError: fibclass.fib() missing 1 required positional argument: 'n'

*****  Class.Function, should pass 'self'

>>> fibclass.fib(1,100)
0 1 1 2 3 5 8 13 21 34 55 89
self
1


>>> f=fibclass()
>>> f.fib(1,100)
Traceback (most recent call last):
  File "<python-input-41>", line 1, in <module>
    f.fib(1,100)
    ~~~~~^^^^^^^
TypeError: fibclass.fib() takes 2 positional arguments but 3 were given

*****  Instance.method, should not pass 'self'

>>> f.fib(100)
0 1 1 2 3 5 8 13 21 34 55 89
self


>>> class car:
...
...     def car_method():
...        print("Inside Car method")
...
... a = car()
... a.car_method()
...
Traceback (most recent call last):
  File "<python-input-197>", line 7, in <module>
    a.car_method()
    ~~~~~~~~~~~~^^
	
 


 >> def fn(self)


In Python, when defining a method within a class, it typically receives at least one argument, conventionally named self, 
which refers to the instance of the class. This self argument is implicitly passed when you call the method on an object.
Though it's a general convention to use self as it is more readable to Python programmers and Python documentation,

However, you can define a method within a class that does not explicitly take self as an argument by using the 
@staticmethod decorator. 

Static methods are functions that belong to the class but do not operate on a specific instance of the class. 
They behave like regular functions, but they are defined within the class's namespace.
Here's how to write a function without an explicit self argument inside a class using @staticmethod:

class MyClass:
    def __init__(self, value):
        self.value = value

    def instance_method(self):
        """
        This is a regular instance method that takes 'self'.
        It can access instance attributes like self.value.
        """
        print(f"Instance method called. Value: {self.value}")

    @staticmethod
    def static_method():
        """
        This is a static method. It does not take 'self'
        and cannot directly access instance attributes.
        """
        print("Static method called. No instance data accessed.")

# Creating an instance of MyClass
obj = MyClass(10)

# Calling the instance method
obj.instance_method()

# Calling the static method (can be called on the class or an instance)
MyClass.static_method()
obj.static_method()



All the methods of the class receive an instance of the class object implicitly as the first argument, when called. >> f = fn() 
hence first parameter need not be passed.
 
Under Car Class >>> class car: def car_method(self) or def car_method(xxx)
a = car()
a.car_method()

or to call any static function without arguments, then the method should be defined like

class car:
  @staticmethod
  def car_method():
    print("Inside Car method")

obj = car()
obj.car_method()

Another example
class Bag:
    def __init__(self):
        self.data = []

    def add1(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)

>>> b=Bag()
>>> b.add1(' First Bag ')
>>> b.addtwice(' Second Bag ')
>>> b.data
[' First Bag ', ' Second Bag ', ' Second Bag ']


Class
-----
from dataclasses import dataclass

@dataclass
class Employee:
    name: str
    dept: str
    salary: int
	

john = Employee('john', 'computer lab', 1000)

john.dept >> 'computer lab'
john.salary >> 1000

Iterators
---------
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one':1, 'two':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
	
	
sys.stderr.write('Warning, log file not found starting a new one\n')

String Pattern Matching
-----------------------
import re
re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')

re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')

Maths
-----
import math
math.cos(math.pi / 4)

math.log(1024, 2)

import statistics
data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
statistics.mean(data)

statistics.median(data)

statistics.variance(data)

Internet Access
---------------
from urllib.request import urlopen
with urlopen('http://worldtimeapi.org/api/timezone/etc/UTC.txt') as response:
    for line in response:
        line = line.decode()             # Convert bytes to a str
        if line.startswith('datetime'):
            print(line.rstrip())         # Remove trailing newline



import smtplib
server = smtplib.SMTP('localhost')
server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
"""To: jcaesar@example.org
From: soothsayer@example.org

Beware the Ides of March.
""")
server.quit()


Date and Time
------------
# dates are easily constructed and formatted
from datetime import date
now = date.today()
now

now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")


# dates support calendar arithmetic
birthday = date(1964, 7, 31)
age = now - birthday
age.days

doctest
--------
def average(values):
    """Computes the arithmetic mean of a list of numbers.

    >>> print(average([20, 30, 70]))
    40.0
    """
    return sum(values) / len(values)

import doctest
doctest.testmod()   # automatically validate the embedded tests

Unit Test
----------
import unittest

class TestStatisticalFunctions(unittest.TestCase):

    def test_average(self):
        self.assertEqual(average([20, 30, 70]), 40.0)
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
        with self.assertRaises(ZeroDivisionError):
            average([])
        with self.assertRaises(TypeError):
            average(20, 30, 70)

unittest.main()  # Calling from the command line invokes all tests


TextWrap
--------
import textwrap
doc = """The wrap() method is just like fill() except that it returns
a list of strings instead of one big string with newlines to separate
the wrapped lines."""

print(textwrap.fill(doc, width=40))

Template
--------
from string import Template
t = Template('${village}folk send $$10 to $cause.')
t.substitute(village='Nottingham', cause='the ditch fund')


import time, os.path
photofiles = ['img_12.jpg', 'img_13.jpg', 'img_14.jpg']
class BatchRename(Template):
    delimiter = '%'

fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ') 
>>>  Enter rename style (%d-date %n-seqnum %f-format):   Ashley_%n%f


t = BatchRename(fmt) which is BatchRename('Ashley_%n%f')
date = time.strftime('%d%b%y')
for i, filename in enumerate(photofiles):
    base, ext = os.path.splitext(filename)
    newname = t.substitute(d=date, n=i, f=ext)
    print('{0} --> {1}'.format(filename, newname))
    
img_12.jpg --> Ashley_0.jpg
img_13.jpg --> Ashley_1.jpg
img_14.jpg --> Ashley_2.jpg

>>>  Enter rename style (%d-date %n-seqnum %f-format):   Viji_%d%f
>>> t=BatchRename(fmt)
>>> for i, filename in enumerate(photofiles):
...     base, ext = os.path.splitext(filename)
...     newname = t.substitute(d=date, n=i, f=ext)
...     print('{0} --> {1}'.format(filename, newname))
...
img_12.jpg --> Viji_04Aug25.jpg
img_13.jpg --> Viji_04Aug25.jpg
img_14.jpg --> Viji_04Aug25.jpg

from the Input  "Viji_%d%f", the %d is requested by the user, hence the date value would be substituted for 'd'
and file format i.e ext (.jpg) would be assigned to 'f'

More on Substitute
------------------
>>> from string import Template
... t=Template('Hello $name, the inbuilt parameters %d %n %f assigned with date, serial, file format')
... t.substitute(name='Viji',d=time.strftime('%d%b%y'),n=1,f=ext)
...
'Hello Viji, the inbuilt parameters %d %n %f assigned with date, serial, file format'


from string import Template
a = [('Ram', 90), ('Ankit', 78), ('Bob', 92)]
t = Template('Hi $name, you have got $marks marks')

for i in a:
    print(t.substitute(name=i[0], marks=i[1]))
	
Hi Ram, you have got 90 marks
Hi Ankit, you have got 78 marks
Hi Bob, you have got 92 marks



 Binary Data Record Layouts
 ---------------------------
import struct

with open('myfile.zip', 'rb') as f:
    data = f.read()

start = 0
for i in range(3):                      # show the first 3 file headers
    start += 14
    fields = struct.unpack('<IIIHH', data[start:start+16])
    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

    start += 16
    filename = data[start:start+filenamesize]
    start += filenamesize
    extra = data[start:start+extra_size]
    print(filename, hex(crc32), comp_size, uncomp_size)

    start += extra_size + comp_size     # skip to the next header


Multi-threading
---------------
import threading, zipfile

class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile

    def run(self):
	    print('Now Starting the Zipping module, when the obj.start()')
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)

background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')

background.join()    # Wait for the background task to finish
print('Main program waited until background was done.')

from collections import deque
d = deque(["task1", "task2", "task3"])
d.append("task4")
print("Handling", d.popleft())

from collections import deque
d = deque(["task1", "task2", "task3"])
d.append("task4")
print("Handling", d.popleft())

Array
-----
from array import array
a = array('H', [4000, 10, 700, 22222])
sum(a)

a[1:3]

Deque/Pop
---------
from collections import deque
d = deque(["task1", "task2", "task3"])
d.append("task4")
print("Handling", d.popleft())

Explicit line joining
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
        return 1
		
Implicit line joining
month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year
			   

Indented piece of Python code:
def perm(l):
        # Compute the list of all permutations of l
    if len(l) <= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r

>>> l='212'
>>> perm(l)
['221', '212', '221', '212', '122', '122']

Keywords
--------
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield

Datetime
--------
from datetime import datetime
date_time=datetime(year=2017,month=8,day=6)
print(f"{date_time:%B %d, %Y}")

>>> August 06, 2017

>>> foo = 'bar'
>>> f"{foo}"
'bar'
>>> f"{foo = }"
"foo = 'bar'"
>>>

>>> from datetime import datetime
>>> date_time=datetime(year=2025,month=8,day=6)
>>> print(date_time)
2025-08-06 00:00:00
>>> print(date_time.date())
2025-08-06

Important Date Class Methods : To gothrough

from datetime import time

# Create time object with hour, minute and second
my_time = time(13, 24, 56)
print("Entered time:", my_time)

>>> Entered time: 13:24:56

# Time object with only minute specified
my_time = time(minute=12)
print("Time with one argument:", my_time)

# Time object with default (00:00:00)
my_time = time()
print("Time without argument:", my_time)

# time(hour=26)      → ValueError: hour must be in 0..23
# time(hour='23')    → TypeError: string passed instead of int

Entered time: 13:24:56
Time with one argument: 00:12:00
Time without argument: 00:00:00

from datetime import datetime

# Initializing constructor
a = datetime(1999, 12, 12)
print(a)

# Initializing constructor with time parameters as well
a = datetime(1999, 12, 12, 12, 12, 12, 342380)
print(a)

------------------------------------------------------------------------------

from datetime import datetime, timedelta

# Get the current date and time
now = datetime.now()
print("Current Date & Time:", now)

# Add 2 years (approx. 730 days)
after_2_years = now + timedelta(days=730)
print("After 2 Years:", after_2_years)

# Add 2 days
after_2_days = now + timedelta(days=2)
print("After 2 Days:", after_2_days)

-------------------------------------------------------------------------------
from datetime import datetime
from pytz import timezone

format = "%Y-%m-%d %H:%M:%S %Z%z"
now_utc = datetime.now(timezone('UTC')) # Current time in UTC
print(now_utc.strftime(format))

timezones = ['Asia/Kolkata', 'Europe/Kiev', 'America/New_York']
for tzone in timezones:
    now_asia = now_utc.astimezone(timezone(tzone))  # Convert to Asia/Kolkata time zone
    print(now_asia.strftime(format))
	
	
--------------------------------------------------------------------------------
a = ["a", "b", "c"]
print(f"List a contains:\n{"\n".join(a)}")

Operators
---------
+       -       *       **      /       //      %      @
<<      >>      &       |       ^       ~       :=
<       >       <=      >=      ==      !=


Class
-----
class Meta(type):
    pass

class MyClass(metaclass=Meta):
    pass

class MySubclass(MyClass):
    pass


Escape Sequence
----------------
'This string will not include \
backslashes or newline characters.'

Explicit Join
-------------
A Logical statement or one/more physical lines with "\"
-------------------------------------------------------
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
        return 1
		
Implicit Join
-------------
month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year

		
			
Code with Indentation
--------------------- 
def perm(l):
        # Compute the list of all permutations of l
    if len(l) <= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r


res = 'Test'
res1=perm(res)
print(res1)


Same Code with Indentation errors
---------------------------------
def perm(l):
 
     if len(lstr) <= 1:
					return [lstr]

	r = []
	for i in range(len(l)):             
		s = l[:i] + l[i+1:]
		p = perm(l[:i] + l[i+1:])    
		for x in p:
			r.append(l[i:i+1] + x)

	return r                
			

res = 'Test'
res1=perm(res)
print(res1)

Same code after indentation corrected
-------------------------------------
def perm(lstr): #runtime error
    
    if len(lstr) <= 1:
                  return [lstr]
        
	r = []
	for i in range(len(lstr)):             
		s = lstr[:i] + lstr[i+1:]
		print ('Inside 1st loop',s)
		pass
		p = perm(lstr[:i] + lstr[i+1:])    
		for x in p:
			r.append(lstr[i:i+1] + x)
			print ('Inside 2nd loop',r)

	return r                
			

res = 'Test'
res1=perm(res)
print(res1)

Atlast corrected
----------------
def perm(l):             
	if len(l) <=1 :
		return [l]
	
	r = []
	for i in range(len(l)):              
		s = l[:i] + l[i+1:]
		p = perm(l[:i] + l[i+1:])    
		for x in p:
			r.append(l[i:i+1] + x)

	return r    
	

Identifiers
-----------
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield



import typing
typing.__name__, typing.__spec__.name

typing.__spec__.name = 'spelling'
typing.__name__, typing.__spec__.name

typing.__name__ = 'keyboard_smashing'
typing.__name__, typing.__spec__.name

lambda
------
a lambda function is a small, anonymous function defined using the lambda keyword. Unlike functions
defined with def, lambda functions are restricted to a single expression, which is implicitly returned. 


A lambda function can take any number of arguments, but can only have one expression.


add_two = lambda x: x + 2
print(add_two(5))  # Output: 7
	
# A lambda function that takes two arguments and returns their sum
add = lambda x, y: x + y
print(add(5, 3)) # Output: 8

# A lambda function that takes three arguments and returns their product
multiply_three = lambda a, b, c: a * b * c
print(multiply_three(2, 4, 6)) # Output: 48


For Loops
--------- 
Example 1:

[(x) for x in [1,2,3] ]
>>> [1, 2, 3]

The else keyword in a for loop specifies a block of code to be executed when the loop is finished:

Example
Print all numbers from 0 to 5, and print a message when the loop has ended:

Example 2:
for x in range(6):
  print(x)
else:
  print("Finally finished!")

>>> 
0
1
2
3
4
5
Finally finished!  

Example 3:
>>> for x in range(1,10):
...   print (x)
1
2
3
4
5
6
7
8
9

Precedence
----------
result = 10 + 5 * 2
# Output: 20 (Multiplication is performed before addition)

result_with_parentheses = (10 + 5) * 2
# Output: 30 (Parentheses force addition to be performed first)

<-----
* / + -
10 + 50/10 * 4 - 6  >>>> result is 24
34 + 12/4 - 45      >>>> result is -8


#There are 2 errors in the below code, but while compiling the interpreter
#will detect #err1 first, later the #err2

employees = {"pam" 30,
             "jim": 28} #err1

for name, age in employees.items():
    print(f"{name.capitalize()} is {age} years old.")

employees1 = {"jack" 30,
             "john": 28} #err2



https://edube.org/learn/pe-1/programming-absolute-basics-compilation-vs-interpretation-11

Compiler : Advantages
•	the execution of the translated code is usually faster;
•	only the user has to have the compiler - the end-user may use the code without it;
•	the translated code is stored using machine language - as it is very hard to understand it, 
•	your own inventions and programming tricks are likely to remain your secret.

Compiler : Dis-Advantages
•	the compilation itself may be a very time-consuming process - you may not be able to run 
	your code immediately after making an amendment;
•	you have to have as many compilers as hardware platforms you want your code to be run on.

Interpreter : Advantages
•	you can run the code as soon as you complete it - there are no additional phases of translation;
•	the code is stored using programming language, not machine language - this means that it can be run on 
	computers using different machine languages; you don't compile your code separately for each different architecture.

Interpreter : Dis-Advantages
•	don't expect interpretation to ramp up your code to high speed - your code will share the computer's power with the interpreter, 
	so it can't be really fast;
•	both you and the end user have to have the interpreter to run your code.


What does this all mean for you?

Python is an interpreted language. This means that it inherits all the described advantages and disadvantages. Of course, 
it adds some of its unique features to both sets.
If you want to program in Python, you'll need the Python interpreter. You won't be able to run your code without it. 
Fortunately, Python is free. This is one of its most important advantages.

Due to historical reasons, languages designed to be utilized in the interpretation manner are 
often called scripting languages, while the source programs encoded using them are called scripts.

What makes Python special?
How does it happen that programmers, young and old, experienced and novice, want to use it? How did it happen that large companies adopted Python and implemented their flagship products using it?

There are many reasons – we've listed some of them already, but let's enumerate them again in a more practical manner:

it's easy to learn – the time needed to learn Python is shorter than for many other languages; this means that it's possible to start the actual programming faster;
it's easy to teach – the teaching workload is smaller than that needed by other languages; this means that the teacher can put more emphasis on general (language-independent) programming techniques, not wasting energy on exotic tricks, strange exceptions and incomprehensible rules;
it's easy to use for writing new software – it's often possible to write code faster when using Python;
it's easy to understand - it's also often easier to understand someone else's code faster if it is written in Python;
it's easy to obtain, install and deploy – Python is free, open and multiplatform; not all languages can boast that.
Of course, Python has its drawbacks, too:

it's not a speed demon – Python does not deliver exceptional performance;
in some cases it may be resistant to some simpler testing techniques – this may mean that debugging Python code can be more difficult than with other languages; fortunately, 
making mistakes is also harder in Python.


Python rivals?
Python has two direct competitors, with comparable properties and predispositions. These are:

Perl – a scripting language originally authored by Larry Wall;
Ruby – a scripting language originally authored by Yukihiro Matsumoto.
The former is more traditional and more conservative than Python, and resembles some of the old languages derived from the classic C programming language.

In contrast, the latter is more innovative and more full of fresh ideas than Python. Python itself lies somewhere between these two creations.

The Internet is full of forums with infinite discussions on the superiority of one of these three over the others, should you wish to learn more about each of them.

Where can we see Python in action?
We see it every day and almost everywhere. It's used extensively to implement complex Internet services like search engines, cloud storage and tools, social media and so on. Whenever you use any of these services, you are actually very close to Python, although you wouldn't know it.

Many developing tools are implemented in Python. More and more everyday-use applications are being written in Python. Lots of scientists have abandoned expensive proprietary tools and switched to Python. Lots of IT project testers have started using Python to carry out repeatable test procedures. The list is long.

Why not Python?
Despite Python's growing popularity, there are still some niches where Python is absent, or is rarely seen:

low-level programming (sometimes called "close to metal" programming): if you want to implement an extremely effective driver or graphical engine, you wouldn't use Python;
applications for mobile devices: although this territory is still waiting to be conquered by Python, it will most likely happen someday.


Resume Point
------------
https://edube.org/learn/pe-1/there-is-more-than-one-python-cpython-and-cython-3


print("\"I\'m\"")
print('""learning""')
print('"""Python"""')

>>>  
  
"I'm"
""learning""
"""Python"""


Operators and their priorities
2 + 3 * 5
---------> 3*5 (1) , 2+15 (2)

multiplications precede additions.
First multiply 3 by 5 and, keeping the 15 in your memory, 
then add it to 2, thus getting the result of 17.

Operators and their bindings
Most of Python's operators have left-sided binding, which means that the calculation of the expression is conducted from left to right.
print(9 % 6 % 2)
from left to right: first 9 % 6 gives 3, and then 3 % 2 gives 1;
since both the operartors are same, 9%6 (3) first then 3%2 =>   1

Operators and their bindings: exponentiation
print(2 ** 2 ** 3)
The result clearly shows that the exponentiation operator uses right-sided binding.

Claude
------







https://claude.ai/public/artifacts/5f9bdfbf-457f-40fd-8aa5-3abf163eca4f

I want to generate the model in local with billions of data (with mentioned json schema) in csv file. These data will have all data including failures and normal cases. It follows the user wise historical pattern, device model wise historical pattern analysis and prediction. Can you write python code to generate model with production grade efficient algorithms.

Correct me if I'm wrong. These are the telemetry information I'll collect and store it in cloud db. We have service centres where they have the failure mobile devices list with device id. So I map the failed device id with the telemetry to get the telemetry of the failure device and give it with label of failure details. Generally I want to label the data to train the model. The model will be trained with billions of data. Finally the model will be deployed, if any telemetry is going to be stored in the cloud database before that model will predict the failure type of the incoming telemetry data. If that prediction from the model is of failure type, we will label that telemetry data of that device with failure details and show some notifications in the app with the failure details.

JSON schema for the telemetry information
{
  // === Identifiers ===
  "record_id": "string",                  // unique log entry id
  "device_id": "string",                  // unique device identifier
  "user_id": "string",                    // unique user identifier
  "timestamp": "string",                  // ISO 8601 timestamp

  // === Device Metadata ===
  "device_model": "string",               // e.g. "Samsung-Galaxy-S22"
  "device_manufacturer": "string",        // e.g. "Samsung"
  "device_batch_number": "string",        // batch/lot id
  "device_production_date": "string",     // YYYY-MM-DD
  "device_age_days": "int",
  "warranty_status": "string",            // in_warranty / expired

  // === OS & Software Metadata ===
  "os_name": "string",                    // "Android"
  "os_version": "string",                 // "13"
  "os_build_number": "string",            // build id
  "software_firmware_version": "string",
  "software_security_patch": "string",    // YYYY-MM-DD
  "software_uptime_hours": "float",
  "software_system_crashes": "int",
  "software_app_crashes": "int",

  // === Battery Telemetry ===
  "battery_level_percent": "float",
  "battery_health_status": "string",
  "battery_temperature_c": "float",
  "battery_voltage_mv": "int",
  "battery_charge_cycles": "int",
  "battery_charging_status": "string",    // charging / discharging
  "battery_current_ma": "int",
  "battery_resistance_mohm": "int",
  "battery_sudden_shutdowns": "int",

  // === CPU Telemetry ===
  "cpu_usage_percent": "float",
  "cpu_temperature_c_avg": "float",
  "cpu_throttle_events": "int",
  "cpu_core_frequencies_mhz": "string",   // comma-separated list
  "cpu_voltage_scaling_errors": "int",
  "cpu_watchdog_resets": "int",

  // === GPU Telemetry ===
  "gpu_usage_percent": "float",
  "gpu_temperature_c": "float",
  "gpu_driver_resets": "int",
  "gpu_frequency_mhz": "int",

  // === Memory Telemetry ===
  "memory_total_mb": "int",
  "memory_used_mb": "int",
  "memory_swap_used_mb": "int",
  "memory_page_faults": "int",
  "memory_oom_kills": "int",
  "memory_ecc_corrected_errors": "int",
  "memory_dma_faults": "int",

  // === Storage Telemetry ===
  "storage_total_gb": "int",
  "storage_used_gb": "int",
  "storage_read_errors": "int",
  "storage_write_errors": "int",
  "storage_bad_block_count": "int",
  "storage_io_latency_ms": "float",
  "storage_wear_level_percent": "float",

  // === Thermal Sensors ===
  "thermal_hotspot_temp_c": "float",
  "thermal_sensor_battery_c": "float",
  "thermal_sensor_cpu_cluster0_c": "float",
  "thermal_sensor_cpu_cluster1_c": "float",
  "thermal_sensor_gpu_c": "float",
  "thermal_sensor_pmic_c": "float",
  "thermal_shutdowns": "int",

  // === Connectivity ===
  "wifi_signal_dbm": "int",
  "wifi_disconnects": "int",
  "wifi_firmware_crashes": "int",
  "wifi_packet_loss_percent": "float",
  "cellular_rsrp_dbm": "int",
  "cellular_drop_calls": "int",
  "cellular_modem_resets": "int",
  "cellular_handshake_failures": "int",

  // === Peripheral Sensors ===
  "peripheral_touchscreen_errors": "int",
  "peripheral_camera_init_failures": "int",
  "peripheral_mic_speaker_faults": "int",
  "peripheral_sensor_hub_desyncs": "int",

  // === Kernel & System ===
  "kernel_panics": "int",
  "kernel_anrs": "int",
  "kernel_irq_storms": "int",
  "kernel_driver_probe_failures": "int",
  "kernel_system_crash_count": "int",
  "kernel_last_boot_reason": "string",

  // === User Metadata ===
  "user_region": "string",                // e.g. "US", "EU"
  "user_account_age_days": "int",
  "user_device_count": "int",             // # devices linked to user
  "user_failure_history_count": "int",    // historical device failures for user
  "user_behavior_profile": "string",      // e.g. "heavy_gamer", "light_user"

  // === Labels for ML ===
  "failure_occurred": "boolean",          // 0 = normal, 1 = failure
  "failure_type": "string",               // e.g. battery, cpu, storage, none
  "failure_timestamp": "string"           // ISO 8601 (if occurred)
}

Consider the telemetry data of mulitple devices of one brand (Samsung devices only)

Requirements

Handle scale: Efficient I/O (e.g. Polars, Dask, streaming).
Feature engineering:
Raw features (CPU, memory, temperature, etc.)
Encoded categoricals (network_status, os_version, oem_model)
Aggregated historical features per user, device, and device model (e.g., rolling means, failure frequency, moving std).
Algorithms (must try multiple):
LightGBM
XGBoost
CatBoost
Graph Neural Networks (GNNs) (If you map telemetry across devices (e.g., same model batch, OS version). Can detect systemic failures across related devices.)
Model Selection:
Use Macro PR-AUC and F1-score as key metrics.
Evaluate per-class performance (not just accuracy).
Support device-wise prediction and per-class threshold tuning.
Output Artifacts:
Trained model (joblib/pickle).
Preprocessing pipeline (scalers, encoders).
Thresholds per class.
Feature importance / explainability summary.
Metrics report (JSON).
Goal

Generate a Python training pipeline that:

Reads the above schema in CSVs.
Trains models with device-wise, model-wise, and user-wise historical features.
Benchmarks multiple algorithms and saves the best production-ready model.
:zap: Your task:
Generate the end-to-end training code (with comments, modular structure, best practices) that fulfills these requirements.

