Ramp up Plan
------------
Tech Upgrade
1. Python Tutorial  Source : https://www.python.org
1.1 Crash course on Python by Google
https://www.coursera.org/learn/python-crash-course

2. HTML
3. CSS
4. Javascript
5. React JS
6. Node JS

ML/AI Reading Plan for PMs
Intro
7. AI for Everyone https://www.coursera.org/learn/ai-for-everyone
8. Generative AI for Everyone https://www.coursera.org/learn/generative-ai-for-everyone
9. MIT Sloan  https://mitsloan.mit.edu/ideas-made-to-matter/machine-learning-explained

Diving Deep
10. Google ML https://developers.google.com/machine-learning/foundational-courses

Use cases
11. AWS – Gen AI Use Cases 
https://aws.amazon.com/ai/generative-ai/use-cases/?ams%23interactive-card-vertical%23pattern-data-2054833178.filter=%257B%2522filters%2522%253A%255B%255D%257D&ams%23interactive-card-vertical%23pattern-data-2054833177.filter=%257B%2522filters%2522%253A%255B%255D%257D
12. GCP – Gen AI Use Cases
https://cloud.google.com/use-cases/generative-ai?hl=en
13. Azure – AI Use Cases
https://www.microsoft.com/en-us/ai/ai-customer-stories

Get Technical
14.Kaggle - Learn (Python)
https://www.kaggle.com/learn

15.Kaggle – Competitions (glance through to understand different domains ML / AI is used)
https://www.kaggle.com/competitions

AI Project Management
16. The Art of AI Product Development book (paid)
https://www.manning.com/books/the-art-of-ai-product-development

17. AI Product Manager Course (paid)
https://www.productmanagementexercises.com/ai-product-manager


Python Tutorial - Coverage  - 08/05/2025
-----------------------------------------
Source : https://www.python.org

Tutorial | Python's syntax and features  *
Language reference | Syntax and language elements |


To refer later
--------------
The Python Standard Library. 
The Python Tutorial.
Extending and Embedding the Python Interpreter 
Python/C API Reference Manual  
https://www.geeksforgeeks.org/angular-js/angularjs/ | Learning platform
https://huggingface.co/ | AI Community
https://docs.djangoproject.com/en/5.2/intro/tutorial01/
Operations supported by Timedelta Class
Integer literals
Floating-point literals
git py
https://www.greatfrontend.com/


Python, pointers to note

Data Type : Numbers
-------------------
17 / 3  # classic division returns a float
17 // 3  # floor division discards the fractional part
17 % 3  # the % operator returns the remainder of the division

Last printed expression in the variable "_"

tax = 12.5 / 100
price = 100.50
price * tax
12.5625
price + _
113.0625
round(_, 2)
113.06

'doesn\'t'  # use \' to escape the single quote...

Multiple lines
--------------
print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")


Text
----

word = 'Python'
word[0]  # character in position 0  >> "P"
word[5]  # character in position 5 >> "n"

word[0:2]  # characters from position 0 (included) to 2 (excluded)    >> "Py"
word[2:5]  # characters from position 2 (included) to 5 (excluded)    >> "thon"

word[:2] + word[2:] 'Python'
word[:4] + word[4:] 'Python'

Lists
-------
cubes = [1, 8, 27, 65, 125]  # something's wrong here
4 ** 3  # the cube of 4 is 64, not 65!

cubes[3] = 64  # replace the wrong value

cubes.append(216)  # add the cube of 6
cubes.append(7 ** 3)  # and the cube of 7
>>> cubes
cubes
[1, 8, 27, 64, 125, 216, 343]

rgb = ["Red", "Green", "Blue"]
rgba = rgb
id(rgb) == id(rgba)  # they reference the same object

rgba.append("Alph")

While
-----
# Fibonacci series:
# the sum of two elements defines the next
a, b = 0, 1
while a < 10:
    print(a)
    a, b = b, a+b
	
	
Collection
----------
# Create a sample collection
users = {'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active'}

# Strategy:  Iterate over a copy
for user, status in users.copy().items():
    if status == 'inactive':
        del users[user]

# Strategy:  Create a new collection
active_users = {}
for user, status in users.items():
    if status == 'active':
        active_users[user] = status

users['New']='New User'
>>> users
{'Hans': 'active', 'Éléonore': 'inactive', '景太郎': 'active', 'New': 'New User'}		
		
list(range(5, 10))
[5, 6, 7, 8, 9]

list(range(0, 10, 3))
[0, 3, 6, 9]

list(range(-10, -100, -30))
[-10, -40, -70]

a = ['Mary', 'had', 'a', 'little', 'lamb']
for i in range(len(a)):
    print(i, a[i])
0 Mary
1 had
2 a
3 little
4 lamb


for n in range(2, 10):
    for x in range(2, n):
        if n % x == 0:
            print(n, 'equals', x, '*', n//x)
            break
    else:
        # loop fell through without finding a factor
        print(n, 'is a prime number')
		
		
while True:
    pass  # Busy-wait for keyboard interrupt (Ctrl+C)
	

def ask_ok(prompt, retries=4, reminder='Please try again!'):
    while True:
        reply = input(prompt)
        if reply in {'y', 'ye', 'yes'}:
            return True
        if reply in {'n', 'no', 'nop', 'nope'}:
            return False
        retries = retries - 1
        if retries < 0:
            raise ValueError('invalid user response')
        print(reminder)
		
		
		
def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
    print("-- This parrot wouldn't", action, end=' ')
    print("if you put", voltage, "volts through it.")
    print("-- Lovely plumage, the", type)
    print("-- It's", state, "!")
	
	
parrot(1000)                                          # 1 positional argument
parrot(voltage=1000)                                  # 1 keyword argument
parrot(voltage=1000000, action='VOOOOOM')             # 2 keyword arguments
parrot(action='VOOOOOM', voltage=1000000)             # 2 keyword arguments
parrot('a million', 'bereft of life', 'jump')         # 3 positional arguments
parrot('a thousand', state='pushing up the daisies')  # 1 positional, 1 keyword

def cheeseshop(kind, *arguments, **keywords):
    print("-- Do you have any", kind, "?")
    print("-- I'm sorry, we're all out of", kind)
    for arg in arguments:
        print(arg)
    print("-" * 40)
    for kw in keywords:
        print(kw, ":", keywords[kw])
		
		
		
		
cheeseshop("Limburger", "It's very runny, sir.",
   "It's really very, VERY runny, sir.",
   shopkeeper="Michael Palin",
   client="John Cleese",
   sketch="Cheese Shop Sketch")
	   
combined_example(1, 2, 3)
combined_example(1, 2, kwd_only=3)
combined_example(1, standard=2, kwd_only=3)
combined_example(pos_only=1, standard=2, kwd_only=3)

# Creating a tuple
my_tuple = ("apple", 123, True)

# Accessing elements
print(my_tuple[0])  # Output: apple

# Attempting to modify (will raise an error)
# my_tuple[0] = "orange"

fruits = ['orange', 'apple', 'pear', 'banana', 'kiwi', 'apple', 'banana']
fruits.count('apple')

fruits.count('tangerine')

fruits.index('banana')

fruits.index('banana', 4)  # Find next banana starting at position 4

fruits.reverse()
fruits

fruits.append('grape')
fruits

fruits.sort()
fruits

fruits.pop()


for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
	
	
basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']
for f in sorted(set(basket)):
    print(f)
	

string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
non_null = string1 or string2 or string3
non_null

fibo.py
-------
# Fibonacci numbers module

def fib(n):
    """Write Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

def fib2(n):
    """Return Fibonacci series up to n."""
    result = []
    a, b = 0, 1
    while a < n:
        result.append(a)
        a, b = b, a+b
    return result


>>> Add the below at the end of the module, to pass the CLA to the .py file 
if __name__ == "__main__":
    import sys
    fib(int(sys.argv[1]))
	
to the end of module

fibo.__name__

import fibo >>  fibo.fib(1000)
from fibo import fib, fib2 >> fib(1000)
from fibo import * >> fib(1000)

from fibo import fib as fibonacci

fibonacci(500)


Reverse String
--------------
def reverse(msg: str):  # <-- this name shadows the 'reverse.py' submodule
    return msg[::-1]    #     in the case of a 'from sound.effects import *'

'12'.zfill(5)
'-3.14'.zfill(7)
'3.14159265359'.zfill(5)

Exception
-----------
while True:
    try:
        x = int(input("Please enter a number: "))
        break
    except ValueError:
        print("Oops!  That was no valid number.  Try again...")
		
		
List Comprehension
------------------
[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]

and it’s equivalent to:

combs = []
for x in [1,2,3]:
    for y in [3,1,4]:
        if x != y:
            combs.append((x, y))


basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'}
print(basket)                      # show that duplicates have been removed
{'orange', 'banana', 'pear', 'apple'}

'orange' in basket                 # >> True
'crabgrass' in basket


# Demonstrate set operations on unique letters from two words

a = set('abracadabra')
b = set('alacazam')

>>> a 
>>> {'a', 'r', 'b', 'c', 'd'}

Looping Techniques
------------------
knights = {'gallahad': 'the pure', 'robin': 'the brave'}
for k, v in knights.items():
    print(k, v)
	
Enumurate
----------
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
	
Fancier Output Formatting
-------------------------
year = 2016
event = 'Referendum'
f'Results of the {year} {event}'

Formatting
----------]

yes_votes = 42_572_654
total_votes = 85_705_149
percentage = yes_votes / total_votes
'{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)

print format : fancy print
--------------------------
table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
for name, phone in table.items():
    print(f'{name:10} ==> {phone:10d}')
	

Encapsulation is one of the core concepts in object-oriented programming and 
describes the bundling of data and methods operating on this data into one unit

https://nextjs.org/docs/getting-started/installation
https://stackblitz.com/edit/nextjs-eirnbv?file=app%2Fpage.tsx

class MyClass:
    """A simple example class"""
    i = 12345

    def __init__(self):
		self.data = 1
	
    def f(self):
        print (self.data)
		
		
>>> x = MyClass()
>>> x.data
1
>>> x.f()
1


class Dog:
    def __init__(self, name, breed):
        self.name = name  # 'self.name' refers to the instance's 'name' attribute
        self.breed = breed

    def bark(self):
        print(f"{self.name} says Woof!") # 'self.name' accesses the instance's name

my_dog = Dog("Buddy", "Golden Retriever")
my_dog.bark() # Output: Buddy says Woof!

self is a conventional name for the first parameter of a method within a class definition

class Dog:

    kind = 'canine'         # class variable shared by all instances

    def __init__(self, name):
        self.name = name    # instance variable unique to each instance

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.kind                  # shared by all dogs
'canine'
>>> e.kind                  # shared by all dogs
'canine'
>>> d.name                  # unique to d
'Fido'
>>> e.name                  # unique to e
'Buddy'

class Dog:

    tricks = []             # mistaken use of a class variable

    def __init__(self, name):
        self.name = name

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks                # unexpectedly shared by all dogs
['roll over', 'play dead']

class Dog:

    def __init__(self, name):
        self.name = name
        self.tricks = []    # creates a new empty list for each dog

    def add_trick(self, trick):
        self.tricks.append(trick)

>>> d = Dog('Fido')
>>> e = Dog('Buddy')
>>> d.add_trick('roll over')
>>> e.add_trick('play dead')
>>> d.tricks
['roll over']
>>> e.tricks
['play dead']


Yes, it is possible to define a Python method within a class that does 
not take any explicit arguments beyond the conventional self parameter 
(for instance methods) or no arguments at all (for static methods).

Class instantiation uses function notation. Just pretend that the class object is a parameterless function that returns a new instance of the class. For example (assuming the above class):

Copy
x = MyClass()

1. Instance Methods without additional arguments:
Instance methods implicitly receive self as their first argument, which 
refers to the instance of the class on which the method is called. Even 
if the method's logic does not require any other input, self is still present.

class MyClass:
    def greet(self):
        """An instance method that takes no explicit arguments other than self."""
        print("Hello from MyClass!")

# Create an instance and call the method
obj = MyClass()
obj.greet()


Ver. 1
-------

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

def where_is(point):
    match point:
        case Point(x=0, y=0):
            print("Origin")
        case Point(x=0, y=y):
            print(f"Y={y}")
        case Point(x=x, y=0):
            print(f"X={x}")
        case Point():
            print("Somewhere else")
        case _:
            print("Not a point")

>>> Locate_axis(Point(1,0))
X=1
>>> Locate_axis(Point(1,1))
No Where
>>> Locate_axis(Point(0,1))
Y=1
>>> Locate_axis(Point(0,0))
Origin
>>> Locate_axis(1)
Not a Point

>>> where_is(Point(1))
Traceback (most recent call last):
  File "<python-input-287>", line 1, in <module>
    where_is(Point(1))
             ~~~~~^^^
TypeError: Point.__init__() missing 1 required positional argument: 'y'


Ver 2
-----
class Point:
    __match_args__ = ('x', 'y')
    def __init__(self, x, y):
        self.x = x
        self.y = y

def where_is(points):
	match points:
		case []:
			print("No points")
		case [Point(0, 0)]:
			print("The origin")
		case [Point(x, y)]:
			print(f"Single point {x}, {y}")
		case [Point(0, y1), Point(0, y2)]:
			print(f"Two on the Y axis at {y1}, {y2}")
		case _:
			print("Something else")







-------------------
def http_error(status):
    match status:
        case 400:
            return "Bad request"
        case 404:
            return "Not found"
        case 418:
            return "I'm a teapot"
        case _:
            return "Something's wrong with the internet"
			

Call the method by Class.Function and  Instance.method		

 
>>> class fibclass:
...     def fib(self,n):
...
...         """Write Fibonacci series up to n."""
...         a, b = 0, 1
...         while a < n:
...             print(a, end=' ')
...             a, b = b, a+b
...         print()
...
...         print('self')
...         self=1
...         print(self)
...
>>>
>>>
>>> fibclass.fib(100)
Traceback (most recent call last):
  File "<python-input-38>", line 1, in <module>
    fibclass.fib(100)
    ~~~~~~~~~~~~^^^^^
TypeError: fibclass.fib() missing 1 required positional argument: 'n'

*****  Class.Function, should pass 'self'

>>> fibclass.fib(1,100)
0 1 1 2 3 5 8 13 21 34 55 89
self
1


>>> f=fibclass()
>>> f.fib(1,100)
Traceback (most recent call last):
  File "<python-input-41>", line 1, in <module>
    f.fib(1,100)
    ~~~~~^^^^^^^
TypeError: fibclass.fib() takes 2 positional arguments but 3 were given

*****  Instance.method, should not pass 'self'

>>> f.fib(100)
0 1 1 2 3 5 8 13 21 34 55 89
self


>>> class car:
...
...     def car_method():
...        print("Inside Car method")
...
... a = car()
... a.car_method()
...
Traceback (most recent call last):
  File "<python-input-197>", line 7, in <module>
    a.car_method()
    ~~~~~~~~~~~~^^
	
 


 >> def fn(self)


In Python, when defining a method within a class, it typically receives at least one argument, conventionally named self, 
which refers to the instance of the class. This self argument is implicitly passed when you call the method on an object.
Though it's a general convention to use self as it is more readable to Python programmers and Python documentation,

However, you can define a method within a class that does not explicitly take self as an argument by using the 
@staticmethod decorator. 

Static methods are functions that belong to the class but do not operate on a specific instance of the class. 
They behave like regular functions, but they are defined within the class's namespace.
Here's how to write a function without an explicit self argument inside a class using @staticmethod:

class MyClass:
    def __init__(self, value):
        self.value = value

    def instance_method(self):
        """
        This is a regular instance method that takes 'self'.
        It can access instance attributes like self.value.
        """
        print(f"Instance method called. Value: {self.value}")

    @staticmethod
    def static_method():
        """
        This is a static method. It does not take 'self'
        and cannot directly access instance attributes.
        """
        print("Static method called. No instance data accessed.")

# Creating an instance of MyClass
obj = MyClass(10)

# Calling the instance method
obj.instance_method()

# Calling the static method (can be called on the class or an instance)
MyClass.static_method()
obj.static_method()



All the methods of the class receive an instance of the class object implicitly as the first argument, when called. >> f = fn() 
hence first parameter need not be passed.
 
Under Car Class >>> class car: def car_method(self) or def car_method(xxx)
a = car()
a.car_method()

or to call any static function without arguments, then the method should be defined like

class car:
  @staticmethod
  def car_method():
    print("Inside Car method")

obj = car()
obj.car_method()

Another example
class Bag:
    def __init__(self):
        self.data = []

    def add1(self, x):
        self.data.append(x)

    def addtwice(self, x):
        self.add(x)
        self.add(x)

>>> b=Bag()
>>> b.add1(' First Bag ')
>>> b.addtwice(' Second Bag ')
>>> b.data
[' First Bag ', ' Second Bag ', ' Second Bag ']


Class
-----
from dataclasses import dataclass

@dataclass
class Employee:
    name: str
    dept: str
    salary: int
	

john = Employee('john', 'computer lab', 1000)

john.dept >> 'computer lab'
john.salary >> 1000

Iterators
---------
for element in [1, 2, 3]:
    print(element)
for element in (1, 2, 3):
    print(element)
for key in {'one':1, 'two':2}:
    print(key)
for char in "123":
    print(char)
for line in open("myfile.txt"):
    print(line, end='')
	
	
sys.stderr.write('Warning, log file not found starting a new one\n')

String Pattern Matching
-----------------------
import re
re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')

re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')

Maths
-----
import math
math.cos(math.pi / 4)

math.log(1024, 2)

import statistics
data = [2.75, 1.75, 1.25, 0.25, 0.5, 1.25, 3.5]
statistics.mean(data)

statistics.median(data)

statistics.variance(data)

Internet Access
---------------
from urllib.request import urlopen
with urlopen('http://worldtimeapi.org/api/timezone/etc/UTC.txt') as response:
    for line in response:
        line = line.decode()             # Convert bytes to a str
        if line.startswith('datetime'):
            print(line.rstrip())         # Remove trailing newline



import smtplib
server = smtplib.SMTP('localhost')
server.sendmail('soothsayer@example.org', 'jcaesar@example.org',
"""To: jcaesar@example.org
From: soothsayer@example.org

Beware the Ides of March.
""")
server.quit()


Date and Time
------------
# dates are easily constructed and formatted
from datetime import date
now = date.today()
now

now.strftime("%m-%d-%y. %d %b %Y is a %A on the %d day of %B.")


# dates support calendar arithmetic
birthday = date(1964, 7, 31)
age = now - birthday
age.days

doctest
--------
def average(values):
    """Computes the arithmetic mean of a list of numbers.

    >>> print(average([20, 30, 70]))
    40.0
    """
    return sum(values) / len(values)

import doctest
doctest.testmod()   # automatically validate the embedded tests

Unit Test
----------
import unittest

class TestStatisticalFunctions(unittest.TestCase):

    def test_average(self):
        self.assertEqual(average([20, 30, 70]), 40.0)
        self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
        with self.assertRaises(ZeroDivisionError):
            average([])
        with self.assertRaises(TypeError):
            average(20, 30, 70)

unittest.main()  # Calling from the command line invokes all tests


TextWrap
--------
import textwrap
doc = """The wrap() method is just like fill() except that it returns
a list of strings instead of one big string with newlines to separate
the wrapped lines."""

print(textwrap.fill(doc, width=40))

Template
--------
from string import Template
t = Template('${village}folk send $$10 to $cause.')
t.substitute(village='Nottingham', cause='the ditch fund')


import time, os.path
photofiles = ['img_12.jpg', 'img_13.jpg', 'img_14.jpg']
class BatchRename(Template):
    delimiter = '%'

fmt = input('Enter rename style (%d-date %n-seqnum %f-format):  ') 
>>>  Enter rename style (%d-date %n-seqnum %f-format):   Ashley_%n%f


t = BatchRename(fmt) which is BatchRename('Ashley_%n%f')
date = time.strftime('%d%b%y')
for i, filename in enumerate(photofiles):
    base, ext = os.path.splitext(filename)
    newname = t.substitute(d=date, n=i, f=ext)
    print('{0} --> {1}'.format(filename, newname))
    
img_12.jpg --> Ashley_0.jpg
img_13.jpg --> Ashley_1.jpg
img_14.jpg --> Ashley_2.jpg

>>>  Enter rename style (%d-date %n-seqnum %f-format):   Viji_%d%f
>>> t=BatchRename(fmt)
>>> for i, filename in enumerate(photofiles):
...     base, ext = os.path.splitext(filename)
...     newname = t.substitute(d=date, n=i, f=ext)
...     print('{0} --> {1}'.format(filename, newname))
...
img_12.jpg --> Viji_04Aug25.jpg
img_13.jpg --> Viji_04Aug25.jpg
img_14.jpg --> Viji_04Aug25.jpg

from the Input  "Viji_%d%f", the %d is requested by the user, hence the date value would be substituted for 'd'
and file format i.e ext (.jpg) would be assigned to 'f'

More on Substitute
------------------
>>> from string import Template
... t=Template('Hello $name, the inbuilt parameters %d %n %f assigned with date, serial, file format')
... t.substitute(name='Viji',d=time.strftime('%d%b%y'),n=1,f=ext)
...
'Hello Viji, the inbuilt parameters %d %n %f assigned with date, serial, file format'


from string import Template
a = [('Ram', 90), ('Ankit', 78), ('Bob', 92)]
t = Template('Hi $name, you have got $marks marks')

for i in a:
    print(t.substitute(name=i[0], marks=i[1]))
	
Hi Ram, you have got 90 marks
Hi Ankit, you have got 78 marks
Hi Bob, you have got 92 marks



 Binary Data Record Layouts
 ---------------------------
import struct

with open('myfile.zip', 'rb') as f:
    data = f.read()

start = 0
for i in range(3):                      # show the first 3 file headers
    start += 14
    fields = struct.unpack('<IIIHH', data[start:start+16])
    crc32, comp_size, uncomp_size, filenamesize, extra_size = fields

    start += 16
    filename = data[start:start+filenamesize]
    start += filenamesize
    extra = data[start:start+extra_size]
    print(filename, hex(crc32), comp_size, uncomp_size)

    start += extra_size + comp_size     # skip to the next header


Multi-threading
---------------
import threading, zipfile

class AsyncZip(threading.Thread):
    def __init__(self, infile, outfile):
        threading.Thread.__init__(self)
        self.infile = infile
        self.outfile = outfile

    def run(self):
	    print('Now Starting the Zipping module, when the obj.start()')
        f = zipfile.ZipFile(self.outfile, 'w', zipfile.ZIP_DEFLATED)
        f.write(self.infile)
        f.close()
        print('Finished background zip of:', self.infile)

background = AsyncZip('mydata.txt', 'myarchive.zip')
background.start()
print('The main program continues to run in foreground.')

background.join()    # Wait for the background task to finish
print('Main program waited until background was done.')

from collections import deque
d = deque(["task1", "task2", "task3"])
d.append("task4")
print("Handling", d.popleft())

from collections import deque
d = deque(["task1", "task2", "task3"])
d.append("task4")
print("Handling", d.popleft())

Array
-----
from array import array
a = array('H', [4000, 10, 700, 22222])
sum(a)

a[1:3]

Deque/Pop
---------
from collections import deque
d = deque(["task1", "task2", "task3"])
d.append("task4")
print("Handling", d.popleft())

Explicit line joining
if 1900 < year < 2100 and 1 <= month <= 12 \
   and 1 <= day <= 31 and 0 <= hour < 24 \
   and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
        return 1
		
Implicit line joining
month_names = ['Januari', 'Februari', 'Maart',      # These are the
               'April',   'Mei',      'Juni',       # Dutch names
               'Juli',    'Augustus', 'September',  # for the months
               'Oktober', 'November', 'December']   # of the year
			   

Indented piece of Python code:
def perm(l):
        # Compute the list of all permutations of l
    if len(l) <= 1:
                  return [l]
    r = []
    for i in range(len(l)):
             s = l[:i] + l[i+1:]
             p = perm(s)
             for x in p:
              r.append(l[i:i+1] + x)
    return r

>>> l='212'
>>> perm(l)
['221', '212', '221', '212', '122', '122']

Keywords
--------
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield

Datetime
--------
from datetime import datetime
date_time=datetime(year=2017,month=8,day=6)
print(f"{date_time:%B %d, %Y}")

>>> August 06, 2017

>>> foo = 'bar'
>>> f"{foo}"
'bar'
>>> f"{foo = }"
"foo = 'bar'"
>>>

>>> from datetime import datetime
>>> date_time=datetime(year=2025,month=8,day=6)
>>> print(date_time)
2025-08-06 00:00:00
>>> print(date_time.date())
2025-08-06

Important Date Class Methods : To gothrough

from datetime import time

# Create time object with hour, minute and second
my_time = time(13, 24, 56)
print("Entered time:", my_time)

>>> Entered time: 13:24:56

# Time object with only minute specified
my_time = time(minute=12)
print("Time with one argument:", my_time)

# Time object with default (00:00:00)
my_time = time()
print("Time without argument:", my_time)

# time(hour=26)      → ValueError: hour must be in 0..23
# time(hour='23')    → TypeError: string passed instead of int

Entered time: 13:24:56
Time with one argument: 00:12:00
Time without argument: 00:00:00

from datetime import datetime

# Initializing constructor
a = datetime(1999, 12, 12)
print(a)

# Initializing constructor with time parameters as well
a = datetime(1999, 12, 12, 12, 12, 12, 342380)
print(a)

------------------------------------------------------------------------------

from datetime import datetime, timedelta

# Get the current date and time
now = datetime.now()
print("Current Date & Time:", now)

# Add 2 years (approx. 730 days)
after_2_years = now + timedelta(days=730)
print("After 2 Years:", after_2_years)

# Add 2 days
after_2_days = now + timedelta(days=2)
print("After 2 Days:", after_2_days)

-------------------------------------------------------------------------------
from datetime import datetime
from pytz import timezone

format = "%Y-%m-%d %H:%M:%S %Z%z"
now_utc = datetime.now(timezone('UTC')) # Current time in UTC
print(now_utc.strftime(format))

timezones = ['Asia/Kolkata', 'Europe/Kiev', 'America/New_York']
for tzone in timezones:
    now_asia = now_utc.astimezone(timezone(tzone))  # Convert to Asia/Kolkata time zone
    print(now_asia.strftime(format))
	
	
--------------------------------------------------------------------------------
a = ["a", "b", "c"]
print(f"List a contains:\n{"\n".join(a)}")

Operators
---------
+       -       *       **      /       //      %      @
<<      >>      &       |       ^       ~       :=
<       >       <=      >=      ==      !=


Class
-----
class Meta(type):
    pass

class MyClass(metaclass=Meta):
    pass

class MySubclass(MyClass):
    pass
	
	
